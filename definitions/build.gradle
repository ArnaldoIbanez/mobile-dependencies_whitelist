apply plugin: "jacoco"
apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin:'application'
apply plugin:'maven'
apply plugin:'java'

project.version = '1.2.24'
project.group = 'com.mercadolibre.melidata.catalog'

task wrapper(type: Wrapper) {
    gradleVersion = '2.1'
}

buildscript {
    repositories {
        mavenCentral()
    }
}

repositories {
	mavenCentral()
	jcenter()
	maven { url "http://git.ml.com:8081/nexus/content/groups/ML" }
	maven { url "http://git.ml.com:8081/nexus/content/repositories/MLGrailsPlugins" }
	maven { url "http://git.ml.com:8081/nexus/content/groups/Arquitectura" }
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.3.11'
    compile 'com.amazonaws:aws-java-sdk:1.11.68'
    compile 'commons-io:commons-io:2.4'
    compile 'com.mercadolibre.melidata.catalog:commons:0.0.6-initaitive'
    compile group: 'com.mercadolibre.melidata.catalog', name: 'definitions', version: '1.2.17'
    compile group: 'com.facebook.presto', name: 'presto-jdbc', version: '0.220'
    compile group: 'com.googlecode.json-simple', name: 'json-simple', version: '1.1.1'
    compile group: 'org.hamcrest', name: 'hamcrest-core', version: '1.3'
    compile group: 'joda-time', name: 'joda-time', version: '2.9.4'
    compile group: 'junit', name: 'junit', version: '4.12'
    compile group: 'commons-cli', name: 'commons-cli', version: '1.2'

    testCompile 'junit:junit:4.+'
}

test {
    afterTest { desc, result ->
        println "Executing test ${desc.name} [${desc.className}] with result: ${result.resultType}"
    }
}


jacoco {
    toolVersion = "0.7.1.201405082137"
    reportsDir = file("$buildDir/customJacocoReportDir")
}
jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.destination "${buildDir}/jacocoHtml"
    }
}

task coverage (dependsOn:[":test",":jacocoTestReport"]) << {
    println("Coverage, check: ${buildDir}/jacocoHtml")
}

task testAll (dependsOn: 'classes', type: JavaExec) {
    main = 'tests'
    classpath = sourceSets.main.runtimeClasspath
    args = ["melidata", "shipping", "advertising", "component_prints", "cx_help_channels", "recommendations"]
}

task testMelidata (dependsOn: 'classes', type: JavaExec) {
    main = 'testCatalog'
    classpath = sourceSets.main.runtimeClasspath
    args = ["melidata"]
}

task testShipping (dependsOn: 'classes', type: JavaExec) {
    main = 'testCatalog'
    classpath = sourceSets.main.runtimeClasspath
    args = ["shipping"]
}

task testAdvertising (dependsOn: 'classes', type: JavaExec) {
    main = 'testCatalog'
    classpath = sourceSets.main.runtimeClasspath
    args = ["advertising"]
}

task testComponentPrints (dependsOn: 'classes', type: JavaExec) {
    main = 'testCatalog'
    classpath = sourceSets.main.runtimeClasspath
    args = ["component_prints"]
}

task testCxHelpChannels (dependsOn: 'classes', type: JavaExec) {
    main = 'testCatalog'
    classpath = sourceSets.main.runtimeClasspath
    args = ["cx_help_channels"]
}

task testRecommendations (dependsOn: 'classes', type: JavaExec) {
    main = 'testCatalog'
    classpath = sourceSets.main.runtimeClasspath
    args = ["recommendations"]
}

task testCronnedQueries (dependsOn: 'classes', type: JavaExec) {
    main = 'testCronnedQueries'
    classpath = sourceSets.main.runtimeClasspath
}

task testMetrics (dependsOn: 'classes', type: JavaExec) {
    main = 'testMetrics'
    classpath = sourceSets.main.runtimeClasspath
}

task uploadAllCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["melidata", "shipping", "advertising", "component_prints", "cx_help_channels", "recommendations"]
}

task uploadMeliDataCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["melidata"]
}

task uploadShippingCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["shipping"]
}

task uploadAdvertisingCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["advertising"]
}

task uploadComponentPrintsCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["component_prints"]
}

task uploadCxHelpChannelsPrintsCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["cx_help_channels"]
}

task uploadRecommendationsCatalog(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.CatalogUploader'
    classpath = sourceSets.main.runtimeClasspath
    args = ["recommendations"]
}

task uploadMetrics(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.MetricsUploader'
    classpath = sourceSets.main.runtimeClasspath
}

task uploadBatchQueries(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.QueriesUploader'
    classpath = sourceSets.main.runtimeClasspath
}

task exportCronQueries(type:JavaExec) {
    main = 'com.melidata.metrics.format.QueryFormatter'
    classpath = sourceSets.main.runtimeClasspath
}

task validate(type:JavaExec) {
    main = 'com.melidata.definitions.validate.Validate'
    classpath = sourceSets.main.runtimeClasspath
    if (project.hasProperty('args')) args project.args.split()
}

task uploadWhitelist(type:JavaExec) {
    main = 'com.melidata.definitions.uploaders.WhitelistPathUploader'
    classpath = sourceSets.main.runtimeClasspath
}

task exportMelidata(type:JavaExec) {
    def mainClass
    if (format == 'hive')
        mainClass = "com.melidata.definitions.format.HiveFormatter"
    else
        throw new IllegalArgumentException("Invalid format. Must be 'hive' or 'json'")

    main = mainClass
    classpath = sourceSets.main.runtimeClasspath
    args ["melidata"]
}

task exportShipping(type:JavaExec) {
    def mainClass
    if (format == 'hive')
        mainClass = "com.melidata.definitions.format.HiveFormatter"
    else
        throw new IllegalArgumentException("Invalid format. Must be 'hive' or 'json'")
    main = mainClass
    classpath = sourceSets.main.runtimeClasspath
    args ["shipping"]
}

task exportAdvertising(type:JavaExec) {
    def mainClass
    if (format == 'hive')
        mainClass = "com.melidata.definitions.format.HiveFormatter"
    else
        throw new IllegalArgumentException("Invalid format. Must be 'hive' or 'json'")
    main = mainClass
    classpath = sourceSets.main.runtimeClasspath
    args ["advertising"]
}

task exportComponentPrints(type:JavaExec) {
    def mainClass
    if (format == 'hive')
        mainClass = "com.melidata.definitions.format.HiveFormatter"
    else
        throw new IllegalArgumentException("Invalid format. Must be 'hive' or 'json'")
    main = mainClass
    classpath = sourceSets.main.runtimeClasspath
    args ["component_prints"]
}

task exportCxHelpChannels(type:JavaExec) {
    def mainClass
    if (format == 'hive')
        mainClass = "com.melidata.definitions.format.HiveFormatter"
    else
        throw new IllegalArgumentException("Invalid format. Must be 'hive' or 'json'")
    main = mainClass
    classpath = sourceSets.main.runtimeClasspath
    args ["cx_help_channels"]
}

task exportRecommendations(type:JavaExec) {
    def mainClass
    if (format == 'hive')
        mainClass = "com.melidata.definitions.format.HiveFormatter"
    else
        throw new IllegalArgumentException("Invalid format. Must be 'hive' or 'json'")
    main = mainClass
    classpath = sourceSets.main.runtimeClasspath
    args ["recommendations"]
}

task exportMetrics(type:JavaExec) {
    main = "com.melidata.metrics.format.MetricsFormatter"
    classpath = sourceSets.main.runtimeClasspath
}

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: 'http://git.ml.com/nexus/content/repositories/releases') {
                authentication(userName: 'mlGrailsPluginDeployer', password: '123456')
            }
            pom.groupId = project.group
            pom.artifactId = 'definitions'
            pom.version = project.version
        }
    }
}
